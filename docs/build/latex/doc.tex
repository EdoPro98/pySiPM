%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}


\usepackage{amsmath}
\usepackage{amssymb}
\DeclareRobustCommand{\and}{\end{tabular}\kern-\tabcolsep\\\begin{tabular}[t]{c}}


\title{pySiPM Documentation}
\date{May 14, 2020}
\release{0.1}
\author{Edoardo Proserpio\and Massimiliano Antonello\and Romualdo Santoro}
\newcommand{\sphinxlogo}{\sphinxincludegraphics{LogopySiPM.pdf}\par}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Introduction}
\label{\detokenize{introduction:introduction}}\label{\detokenize{introduction::doc}}

\section{What is pySiPM?}
\label{\detokenize{introduction:what-is-pysipm}}
pySiPM is a toolkit developed with the aim of simulating SiPM signals.
Even thou it has been initially developed to accomplish a specific task it has evolved in a way such that it can simulate generic SiPM signals.


\section{Why it was created?}
\label{\detokenize{introduction:why-it-was-created}}
Originally it has been developed to simulate the SiPM digitized signals using the information given by a Geant4 simulation of the IDEA Dual Readout Calorimeter in which about 130 millions of SiPMs are coupled with scintillating and cherenkov fibers.
Its aim is to study the effects induced by the SiPM readout system in the detector response and eventually to help in the right choice of sensors and electronic setup.
It is also used to simulate the full geometry of IDEA Calorimeter and reconstruct high energy physics events with the granularity offered by the SiPM readout system.

Its aim is to help in the choice of the right SiPM sensor for a specific task and show how the stochastic noise effects may affect the values measured. Its aim is not to describe a SiPM in the most detailed way but to show how different parameters of the SiPM, signal shape and electric readout may affect the value measured by the user.


\section{Who has created it?}
\label{\detokenize{introduction:who-has-created-it}}
\begin{DUlineblock}{0em}
\item[] pySiPM has been developed for the IDEA collaboration at University of Insubria, department of Science and HighTech.
\item[] The group that has developed pySiPM has an expertise in Silicon PhotoMultipliers devices and their applications.
\end{DUlineblock}
\begin{itemize}
\item {} 
Edoardo Proserpio, physics student at Insubria University \sphinxhref{mailto:eproserpio@studenti.uninsubria.it}{eproserpio@studenti.uninsubria.it}

\item {} 
PhD Massimiliano Antonello, research fellow at INFN Milano \sphinxhref{mailto:massimiliano.antonello@mi.infn.it}{massimiliano.antonello@mi.infn.it}

\item {} 
PhD Romualdo Santoro, researcher and professor at Insubria University \sphinxhref{mailto:romualdo.santoro@uninsubria.it}{romualdo.santoro@uninsubria.it}

\end{itemize}


\chapter{Installation}
\label{\detokenize{installation:installation}}\label{\detokenize{installation::doc}}
\begin{sphinxadmonition}{tip}{Tip:}
At the moment pySiPM is just a collection of .py files including all the necessaries functions to simulate a SiPM, hence you just need to clone the GitHub repository and make sure that you have installed all the needed Python modules.
\end{sphinxadmonition}


\section{Requirments}
\label{\detokenize{installation:requirments}}

\subsection{Obbligatory}
\label{\detokenize{installation:obbligatory}}\begin{itemize}
\item {} 
\sphinxstylestrong{Python}: pySiPM is created using Python3.6 but it should also work with newer versions of Python.
\begin{itemize}
\item {} 
numpy

\item {} 
matplotlib

\item {} 
uproot

\item {} 
h5py

\end{itemize}

\item {} 
\sphinxstylestrong{Cern ROOT}: Version 6.19 and newer. It has been tested on ROOT versions 6.19 \sphinxhyphen{} 6.20 and 6.20.2. At the moment ROOT is only used for visualization but in future versions it will be used for I/O operations. \sphinxhref{https://root.cern.ch/downloading-root}{Download ROOT}

\item {} 
\sphinxstylestrong{Fortran}: f2py is used to wrap fortran code. f2py is installed by default when installing Numpy.

\end{itemize}


\subsection{Optional}
\label{\detokenize{installation:optional}}\begin{itemize}
\item {} 
\sphinxstylestrong{Cupy}: Cupy is used to take advantage of Nvidia GPUs computing power. It requires CUDA to be installed in the system. \sphinxhref{https://developer.nvidia.com/cuda-downloads}{Download CUDA}

\end{itemize}


\section{Linux How To}
\label{\detokenize{installation:linux-how-to}}
\begin{DUlineblock}{0em}
\item[] When installing ROOT make sure to link it with Python3: \sphinxcode{\sphinxupquote{\sphinxhyphen{}DPYTHON\_EXECUTABLE=\textbackslash{}usr\textbackslash{}bin\textbackslash{}python3 \sphinxhyphen{}DPYTHON\_INCLUDE\_DIR=\textbackslash{}usr\textbackslash{}include\textbackslash{}python3.6\textbackslash{}Python.h}}
\item[] If Cern ROOT is not installed it is better to install it \sphinxstylestrong{after} Nvidia CUDA, so it can find CUDA libraries and build upon them using \sphinxcode{\sphinxupquote{\sphinxhyphen{}Dcuda=ON}}
\end{DUlineblock}

To install Python packages needed:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python3 \PYGZhy{}m pip install numpy matplotlib uproot
\end{sphinxVerbatim}

To install CUDA (Nvidia Gpu needed) and Cupy (code example for Ubuntu 18.04):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
wget http://developer.download.nvidia.com/compute/cuda/10.2/Prod/local\PYGZus{}installers/cuda\PYGZus{}10.2.89\PYGZus{}440.33.01\PYGZus{}linux.run
sudo sh cuda\PYGZus{}10.2.89\PYGZus{}440.33.01\PYGZus{}linux.run
\end{sphinxVerbatim}

To set environment variables in .bashrc add:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{export} \PYG{n+nv}{CUDADIR}\PYG{o}{=}/usr/local/cuda\PYGZhy{}10.2
\PYG{n+nb}{export} \PYG{n+nv}{PATH}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}CUDADIR}/bin\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{PATH}\PYG{p}{:}\PYG{p}{+}\PYG{p}{:}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{PATH}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+si}{\PYGZcb{}}
\PYG{n+nv}{LD\PYGZus{}LIBRARY\PYGZus{}PATH}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}CUDADIR}/lib64\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{LD\PYGZus{}LIBRARY\PYGZus{}PATH}\PYG{p}{:}\PYG{p}{+}\PYG{p}{:}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{LD\PYGZus{}LIBRARY\PYGZus{}PATH}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+si}{\PYGZcb{}}
\PYG{n+nv}{LD\PYGZus{}LIBRARY\PYGZus{}PATH}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}CUDADIR}/extras/CUPTI/lib64\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{LD\PYGZus{}LIBRARY\PYGZus{}PATH}\PYG{p}{:}\PYG{p}{+}\PYG{p}{:}\PYG{l+s+si}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{LD\PYGZus{}LIBRARY\PYGZus{}PATH}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+si}{\PYGZcb{}}
\end{sphinxVerbatim}

Then Cupy can be installed via pip:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python3 \PYGZhy{}m pip install cupy
\end{sphinxVerbatim}

For further help on CUDA installation check Nvidia installation guide: \sphinxhref{https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html\#runfile}{CUDA installation guide}

To download CUDA for other architectures: \sphinxhref{https://developer.nvidia.com/cuda-downloads}{Download CUDA}


\section{Compilation of shared libraries}
\label{\detokenize{installation:compilation-of-shared-libraries}}
\begin{DUlineblock}{0em}
\item[] Fortran libraries have to be compiled using f2py. A Makefile.py automatizes the procedure.
\item[] Before running the simulation make sure to compile the libraries by running:
\end{DUlineblock}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python3 Makefile.py
\end{sphinxVerbatim}

Shared libraries can be eventually compiled manually by using:

\begin{sphinxVerbatim}[commandchars=\\\{\}]

\end{sphinxVerbatim}

f2py3.6 \sphinxhyphen{}c \textendash{}opts = ‘\sphinxhyphen{}Ofast \sphinxhyphen{}funroll\sphinxhyphen{}all\sphinxhyphen{}loops \sphinxhyphen{}ffast\sphinxhyphen{}math \sphinxhyphen{}march=native \sphinxhyphen{}pipe’ \sphinxhyphen{}m FortranFunctions FortranFunctions.f90


\chapter{Files Structure}
\label{\detokenize{structure:files-structure}}\label{\detokenize{structure::doc}}
In this section the file structure used to build the simulation is explained. You can find a brief description of the files used and they content. For a detailed explanation see the individual sections.


\section{Main}
\label{\detokenize{structure:main}}
The simulation is made of a series of function and variables that are used in the main file to generate a SiPM event. In the main file the number of cells triggered is calculated and the signal is generated accordingly. In this file the signal is also analysed.

The structure of the main file may be modified by the user to include more advanced analysis of the digitised.  signal.


\subsection{main.py}
\label{\detokenize{structure:main-py}}
In this file the functions present in the \sphinxtitleref{libs} folder are combined to generate a complete SiPM event
\index{SiPM() (in module main)@\spxentry{SiPM()}\spxextra{in module main}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structure:main.SiPM}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{main.}}\sphinxbfcode{\sphinxupquote{SiPM}}}{\emph{\DUrole{n}{times}}, \emph{\DUrole{n}{other}}}{}
Function that calls all the procedures defined in libs to generate a complete SiPM event.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{times}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} This array contains the arriving time of each photon on the SiPM sensor surface. This array is the input of the simulation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{other}} (\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}) \textendash{} This variable may contain other informations about the event generated. It can be the event id, the arriving time inserted in the simulation or the real number of photons inserted in the simulation. This tuple will be copied as it is in the output.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{integral} (\sphinxstyleemphasis{double}) \textendash{} The integral of the signal calculated in the integration gate

\item {} 
\sphinxstylestrong{peak} (\sphinxstyleemphasis{double}) \textendash{} The height of the signal in the integration gate

\item {} 
\sphinxstylestrong{tstart} (\sphinxstyleemphasis{double}) \textendash{} The time of arrival of the signal in ns defined as the first sample over the threshld of 1.5

\item {} 
\sphinxstylestrong{other} (\sphinxstyleemphasis{tuple}) \textendash{} The copy of the \sphinxtitleref{other} variable given in the input

\item {} 
\sphinxstylestrong{signal} (\sphinxstyleemphasis{np.ndarray(float32)}) \textendash{} If the options \sphinxhyphen{}W is enabled the complete SiPM signal will be passed in the output. Otherwise this output is None

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\section{Variables}
\label{\detokenize{structure:variables}}

\subsection{variables.py}
\label{\detokenize{structure:variables-py}}
\begin{DUlineblock}{0em}
\item[] The file \sphinxtitleref{variables.py} contains all the variables needed to describe the SiPM sensor, the simulation behavior and the signal analysis.
\item[] Here is a brief description of all the parameters with their default value.
\end{DUlineblock}
\begin{itemize}
\item {} 
SiPM Settings:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{size = 1}} Size of the SiPM sensitive area in mm (side)

\item {} 
\sphinxcode{\sphinxupquote{cellsize = 25}} Pitch of a single sensitive cell in um

\item {} 
\sphinxcode{\sphinxupquote{dcr = 200e3}} Dark count rate in kHz

\item {} 
\sphinxcode{\sphinxupquote{xt = 0.03}} Optical crosstalk probability

\item {} 
\sphinxcode{\sphinxupquote{ap = 0.02}} Afterpulsing probability

\item {} 
\sphinxcode{\sphinxupquote{trise = 1}} Rising time of the signal in ns

\item {} 
\sphinxcode{\sphinxupquote{tfall = 50}} Falling time of the signal in ns

\item {} 
\sphinxcode{\sphinxupquote{cellrecovery = 20}} Recovery time of the single SiPM cell in ns

\item {} 
\sphinxcode{\sphinxupquote{tauapfast = 15}} Time constant of afterpulses delay in ns (fast component)

\item {} 
\sphinxcode{\sphinxupquote{tauapslow = 85}} Time constant of afterpulses delay in ns (slow component)

\item {} 
\sphinxcode{\sphinxupquote{ccgv = 0.05}} Cell to cell gain variation (sigma)

\item {} 
\sphinxcode{\sphinxupquote{SNR = 30}} Signal to noise ratio

\item {} 
\sphinxcode{\sphinxupquote{basespread = 0}} Spread of the baseline of the signal (sigma)

\end{itemize}

\item {} 
Signal analysis settings:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{siglen = 500}} Total length of the signal in ns

\item {} 
\sphinxcode{\sphinxupquote{sampling = 0.1}} Samlping time in ns (1 = 1ns, 0.1 = 100ps)

\item {} 
\sphinxcode{\sphinxupquote{intstart = 20}} Start of the integration gate in ns

\item {} 
\sphinxcode{\sphinxupquote{intgate = 300}} Length of the integration gate in ns

\item {} 
\sphinxcode{\sphinxupquote{pregate = 20}} Length of the pregate

\end{itemize}

\item {} 
Simulation settings:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{fastDCR = False}} Enables faster generation of dark count events

\item {} 
\sphinxcode{\sphinxupquote{fastXT = False}}  Enable faster generation of crosstalk events

\item {} 
\sphinxcode{\sphinxupquote{fastSIG = True}}  Enables faster computation of signals

\end{itemize}

\end{itemize}

For a more detailed description of each variable see …


\section{Functions}
\label{\detokenize{structure:functions}}

\subsection{libs/lib.py}
\label{\detokenize{structure:libs-lib-py}}
\begin{DUlineblock}{0em}
\item[] This file contains all the functions that are used to generate the event and the SiPM signal.
\item[] Here is a brief description of all the functions with their signature.
\end{DUlineblock}
\index{addDCR() (in module libs.lib)@\spxentry{addDCR()}\spxextra{in module libs.lib}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structure:libs.lib.addDCR}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{libs.lib.}}\sphinxbfcode{\sphinxupquote{addDCR}}}{\emph{\DUrole{n}{rate}}}{}
Function that generates times of dcr events.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{rate}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} Rate of dcr in kHz

\item[{Returns}] \leavevmode
\sphinxstylestrong{dcrTime} \textendash{} Array containing dcr times

\item[{Return type}] \leavevmode
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{SiPMEventAction() (in module libs.lib)@\spxentry{SiPMEventAction()}\spxextra{in module libs.lib}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structure:libs.lib.SiPMEventAction}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{libs.lib.}}\sphinxbfcode{\sphinxupquote{SiPMEventAction}}}{\emph{\DUrole{n}{time}}, \emph{\DUrole{n}{xt}}}{}
evtsGen(time,xt)

Function that calculates signal height for each SiPM cell and adds optical crosstalk events.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Array containing the time at which SiPM cells are fired

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{xt}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} Value of optical crosstalk probability

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{evtTimes} (\sphinxstyleemphasis{np.ndarray(int32)}) \textendash{} Array containing the time at wich SiPM cells are fired, including xt events (sorted)

\item {} 
\sphinxstylestrong{sigH} (\sphinxstyleemphasis{np.ndarray(float32)}) \textendash{} Array containing the pulse height of each fired SiPM cell

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{SiPMSignalAction() (in module libs.lib)@\spxentry{SiPMSignalAction()}\spxextra{in module libs.lib}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structure:libs.lib.SiPMSignalAction}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{libs.lib.}}\sphinxbfcode{\sphinxupquote{SiPMSignalAction}}}{\emph{\DUrole{n}{times}}, \emph{\DUrole{n}{sigH}}, \emph{\DUrole{n}{SNR}}, \emph{\DUrole{n}{basespread}}}{}
signalGen(times,sigH,SNR,basespread)

Function that passes signal height and times to the main function that generates single signals. Also adds noise.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{times}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{int32}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Array containing the time at wich SiPM cells are fired, including xt events (sorted)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sigH}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{float32}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Array containing the pulse height of each fired SiPM cell

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{SNR}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} The signal to noise ratio of the noise to add

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{basespread}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} Sigma of the value to add as baseline

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{signal} \textendash{} Array containing the generated SiPM signal

\item[{Return type}] \leavevmode
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{PulseCPU() (in module libs.lib)@\spxentry{PulseCPU()}\spxextra{in module libs.lib}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structure:libs.lib.PulseCPU}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{libs.lib.}}\sphinxbfcode{\sphinxupquote{PulseCPU}}}{\emph{\DUrole{n}{t}}, \emph{\DUrole{n}{h}}}{}
Function that generates the signal from a single SiPM cell. This is the “fast” version that uses a pre\sphinxhyphen{}computed signal shape and translates it in time.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32}}) \textendash{} Time at which the cell is triggered

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h}} (\sphinxstyleliteralemphasis{\sphinxupquote{float32}}) \textendash{} The relative pulse height of the cell signal

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{s} \textendash{} Array containing the generated cell signal

\item[{Return type}] \leavevmode
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{sigPlot() (in module libs.lib)@\spxentry{sigPlot()}\spxextra{in module libs.lib}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structure:libs.lib.sigPlot}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{libs.lib.}}\sphinxbfcode{\sphinxupquote{sigPlot}}}{\emph{\DUrole{n}{signal}}, \emph{\DUrole{n}{sigTimes}}, \emph{\DUrole{n}{dcrTime}}, \emph{\DUrole{n}{dev}}}{}
Function that plots each signal pulse produced in the simulation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{signal}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Array containing the generated SiPM signal

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sigTimes}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Array containing all photons events times (including xt)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dcrTime}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Array containing dcr events times

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dev}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} String that describes the device on which the signal is computed

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{initializeRandomPool() (in module libs.lib)@\spxentry{initializeRandomPool()}\spxextra{in module libs.lib}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structure:libs.lib.initializeRandomPool}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{libs.lib.}}\sphinxbfcode{\sphinxupquote{initializeRandomPool}}}{}{}
Function that initializes random seeds for each worker in the multiprocessing Pool

\end{fulllineitems}

\index{somestats() (in module libs.lib)@\spxentry{somestats()}\spxextra{in module libs.lib}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structure:libs.lib.somestats}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{libs.lib.}}\sphinxbfcode{\sphinxupquote{somestats}}}{\emph{\DUrole{n}{output}}}{}
Function that displays histograms of generated events
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{output}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Array containing output of the simulation. This array contains the integral, peak and starting time in the first three columns.

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
See docs for a detailed description of integral, peak and tstart
\end{sphinxadmonition}

\end{fulllineitems}



\subsection{libs/libCPU.py}
\label{\detokenize{structure:libs-libcpu-py}}
\begin{DUlineblock}{0em}
\item[] This file contains the functions used to compute the SiPM signal using the CPU.
\item[] Here is a brief description of all the functions with their signature.
\end{DUlineblock}
\index{SiPMSignalAction() (in module libs.libCPU)@\spxentry{SiPMSignalAction()}\spxextra{in module libs.libCPU}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structure:libs.libCPU.SiPMSignalAction}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{libs.libCPU.}}\sphinxbfcode{\sphinxupquote{SiPMSignalAction}}}{\emph{\DUrole{n}{times}}, \emph{\DUrole{n}{sigH}}, \emph{\DUrole{n}{SNR}}, \emph{\DUrole{n}{basespread}}}{}
Function that passes signal height and times to the main function that generates single signals. Also adds noise.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{times}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{int32}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Array containing the time at wich SiPM cells are fired, including xt events (sorted)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sigH}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{float32}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Array containing the pulse height of each fired SiPM cell

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{SNR}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} The signal to noise ratio of the noise to add

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{basespread}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} Sigma of the value to add as baseline

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{signal} \textendash{} Array containing the generated SiPM signal

\item[{Return type}] \leavevmode
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{PulseCPU() (in module libs.libCPU)@\spxentry{PulseCPU()}\spxextra{in module libs.libCPU}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structure:libs.libCPU.PulseCPU}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{libs.libCPU.}}\sphinxbfcode{\sphinxupquote{PulseCPU}}}{\emph{\DUrole{n}{t}}, \emph{\DUrole{n}{h}}}{}
Function that generates the signal from a single SiPM cell. This is the “full” version that computes the signal shape on CPU by evaluating the signal shape function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32}}) \textendash{} Time at which the cell is triggered

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h}} (\sphinxstyleliteralemphasis{\sphinxupquote{float32}}) \textendash{} The relative pulse height of the cell signal

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{s} \textendash{} Array containing the generated cell signal

\item[{Return type}] \leavevmode
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}



\subsection{libs/libGPU.py}
\label{\detokenize{structure:libs-libgpu-py}}
\begin{DUlineblock}{0em}
\item[] This file contains the functions used to compute the SiPM signal using the GPU.
\item[] Here is a brief description of all the functions with their signature.
\end{DUlineblock}
\index{SiPMSignalAction() (in module libs.libGPU)@\spxentry{SiPMSignalAction()}\spxextra{in module libs.libGPU}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structure:libs.libGPU.SiPMSignalAction}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{libs.libGPU.}}\sphinxbfcode{\sphinxupquote{SiPMSignalAction}}}{\emph{\DUrole{n}{times}}, \emph{\DUrole{n}{sigH}}, \emph{\DUrole{n}{SNR}}, \emph{\DUrole{n}{basespread}}}{}
signalGen(times,sigH,SNR,basespread)

Function that passes signal height and times to the main function that generates signals. Also adds noise.
If the number of signals to generate is small uses CPU, else uses GPU to speed up the computation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{times}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{int32}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Array containing the time at wich SiPM cells are fired, including xt events (sorted)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sigH}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{float32}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Array containing the pulse height of each fired SiPM cell

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{SNR}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} The signal to noise ratio of the noise to add

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{basespread}} (\sphinxstyleliteralemphasis{\sphinxupquote{double}}) \textendash{} Sigma of the value to add as baseline

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{signal} \textendash{} Array containing the generated SiPM signal

\item[{Return type}] \leavevmode
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{PulseCPU() (in module libs.libGPU)@\spxentry{PulseCPU()}\spxextra{in module libs.libGPU}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structure:libs.libGPU.PulseCPU}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{libs.libGPU.}}\sphinxbfcode{\sphinxupquote{PulseCPU}}}{\emph{\DUrole{n}{t}}, \emph{\DUrole{n}{h}}}{}
Function that generates the signal from a single SiPM cell. This is the “full” version that computes the signal shape on CPU by evaluating the signal shape function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} (\sphinxstyleliteralemphasis{\sphinxupquote{int32}}) \textendash{} Time at which the cell is triggered

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h}} (\sphinxstyleliteralemphasis{\sphinxupquote{float32}}) \textendash{} The relative pulse height of the cell signal

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{s} \textendash{} Array containing the generated cell signal

\item[{Return type}] \leavevmode
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{PulseGPU() (in module libs.libGPU)@\spxentry{PulseGPU()}\spxextra{in module libs.libGPU}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{structure:libs.libGPU.PulseGPU}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{libs.libGPU.}}\sphinxbfcode{\sphinxupquote{PulseGPU}}}{\emph{\DUrole{n}{t}}, \emph{\DUrole{n}{h}}}{}
PulseCPU(t,h)

Function that generates the signal from all SiPM cells at once. This is the “full” version that computes the signal shape on GPU.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{int32}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Array containing times at which each the cell is triggered

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{float32}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Array containing the relative pulse height of each cell signal

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{s} \textendash{} Array containing the generated SiPM signal

\item[{Return type}] \leavevmode
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}



\section{Other}
\label{\detokenize{structure:other}}

\subsection{scr}
\label{\detokenize{structure:scr}}
This folder contains the source file of the FORTRAN functions that are used to speed\sphinxhyphen{}up the simulation


\subsection{files}
\label{\detokenize{structure:files}}
This folder contains some files used by the simulation and contains pre\sphinxhyphen{}configurations of some SiPM models that can be eventually loaded.
For an explanation on how to write and load an external configuration file see …


\chapter{Setup}
\label{\detokenize{setup:setup}}\label{\detokenize{setup::doc}}

\section{External file setup}
\label{\detokenize{setup:external-file-setup}}
The recommended way to change the parameters of the simulation or the SiPM is to launch the simulation with the option \sphinxcode{\sphinxupquote{\sphinxhyphen{}f filename.txt}}. The file loaded will overwrite the default options.
You can decide to overwrite all the default options or just some of them.

\begin{sphinxadmonition}{note}{Note:}
The file loaded with \sphinxcode{\sphinxupquote{\sphinxhyphen{}f filename.txt}} is read as a .py file, so comments must be preceded by \sphinxtitleref{\#} and every line will be executed as Python code.
\end{sphinxadmonition}

Here is an example of file for a Hamamatzu SiPM S13615\sphinxhyphen{}1025

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{size} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{cellsize} \PYG{o}{=} \PYG{l+m+mi}{25}
\PYG{n}{dcr} \PYG{o}{=} \PYG{l+m+mf}{100e3}
\PYG{n}{xt} \PYG{o}{=} \PYG{l+m+mf}{0.01}
\PYG{n}{ap} \PYG{o}{=} \PYG{l+m+mf}{0.03}
\PYG{n}{SNR} \PYG{o}{=} \PYG{l+m+mi}{30}
\PYG{n}{ccgv} \PYG{o}{=} \PYG{l+m+mf}{0.05}

\PYG{n}{intstart} \PYG{o}{=} \PYG{l+m+mi}{20}
\PYG{n}{intgate} \PYG{o}{=} \PYG{l+m+mi}{300}
\PYG{n}{preg} \PYG{o}{=} \PYG{l+m+mi}{20}
\end{sphinxVerbatim}

\begin{DUlineblock}{0em}
\item[] The list of editable variables can be found at … with a detailed description at …
\item[] Configuration files for some SiPM models are present in the \sphinxtitleref{files} folder and it is a good practice to put your configuration files here.
\end{DUlineblock}


\section{Manual setup}
\label{\detokenize{setup:manual-setup}}
It is also possible to manually change the values in the \sphinxtitleref{variables.py} file. Keep in mind that changes in this files are permanent.

\begin{sphinxadmonition}{danger}{Danger:}
Editing the \sphinxtitleref{variables.py} file may change the behavior of the simulation in an unexpected way! Edit this file only if you know what you are doing.
\end{sphinxadmonition}


\section{Command line options}
\label{\detokenize{setup:command-line-options}}\label{\detokenize{setup:clineopts}}
Some command line options can be parsed to de simulation and can be used to quickly change some parameters of the simulation.
\begin{quote}
\begin{optionlist}{3cm}
\item [\sphinxhyphen{}H]  
Shows an help message and exits. Using \sphinxcode{\sphinxupquote{\sphinxhyphen{}h}} will display the ROOT help message.
\item [\sphinxhyphen{}V]  
Shows the software version and exits.
\item [\sphinxhyphen{}q]  
Switch to silent operation of the simulation.
\item [\sphinxhyphen{}G]  
Displays each generated signal (only for debugging purposes).
\item [\sphinxhyphen{}g]  
Shows histograms of integral, peak and starting time at the end of the simulation.
\item [\sphinxhyphen{}NDCR]  
Turns off dark count events generation.
\item [\sphinxhyphen{}NXT]  
Turns off the generation of optical crosstalk events.
\item [\sphinxhyphen{}NAP]  
Turns off the generation of afterpulses events.
\item [\sphinxhyphen{}FDCR]  
Enables faster generation of dark counts {\hyperref[\detokenize{theory:dcrtheory}]{\sphinxcrossref{\DUrole{std,std-ref}{Dark Counts}}}}
\item [\sphinxhyphen{}FXT]  
Enables faster generation of optical crosstalk {\hyperref[\detokenize{theory:xttheory}]{\sphinxcrossref{\DUrole{std,std-ref}{Optical Crosstalk}}}}
\item [\sphinxhyphen{}SIG]  
Enables computation of each single signal (slower)
\item [\sphinxhyphen{}j \textless{}N\textgreater{}]  
Set the number of parallel workers to N (default is the number of cores detected)
\sphinxhyphen{}d \textless{}dev\textgreater{} If using \sphinxhyphen{}SIG option this can select the device to use \sphinxtitleref{cpu} or \sphinxtitleref{gpu}
\item [\sphinxhyphen{}f \textless{}file.txt\textgreater{}]  
Reads the configuration file selected
\item [\sphinxhyphen{}w \textless{}file.root\textgreater{}]  
Writes the results on a rootfile.
\item [\sphinxhyphen{}W \textless{}file\textgreater{}]  
Saves each digitized wave in a group of a hdf5 file.
\end{optionlist}
\end{quote}


\chapter{Variables}
\label{\detokenize{variables:variables}}\label{\detokenize{variables::doc}}
The variables needed to describe the SiPM and the simulation behavior are global variables and are declared in the \sphinxtitleref{variables.py} file.

Here is the detailed description of each variable:


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{size~:~int}}}
The SiPM lateral size given in millimeters. This value is used to calculate the total number of cells.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{cellsize~:~int}}}
The pitch of a single SiPM cell in micrometers. This value is used to calculate the total number of cells.

\end{fulllineitems}


After converting these two variables both in mm the total number of cells considered in the simulation is then given by:
\begin{equation*}
\begin{split}N_{cell} = \left(\frac{size}{cellsize}\right)^2\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
On a real SiPM the number of cells is usually a bit smaller than the one calculated via geometrical considerations since some area of the sensor is used for the electrical connections. Thou the difference is small and negligible.
\end{sphinxadmonition}


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{dcr~:~double}}}
The dark count rate in kHz of the SiPM. This value must be greater than 0, otherwise it will throw a Division by Zero error. To turn off dcr use the option \sphinxcode{\sphinxupquote{\sphinxhyphen{}NDCR}} as explained in {\hyperref[\detokenize{setup:clineopts}]{\sphinxcrossref{\DUrole{std,std-ref}{Command line options}}}} . For a detailed description of dark counts generation see {\hyperref[\detokenize{theory:dcrtheory}]{\sphinxcrossref{\DUrole{std,std-ref}{Dark Counts}}}}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{xt~:~double}}}
The optical crosstalk probability expressed in the range 0\sphinxhyphen{}1. 0 means no crosstalk events. For a detailed description of optical crosstalk generation see {\hyperref[\detokenize{theory:xttheory}]{\sphinxcrossref{\DUrole{std,std-ref}{Optical Crosstalk}}}}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{ap~:~double}}}
The afterpulsing probability expressed in the range 0\sphinxhyphen{}1. 0 means no afterpulses events. For a detailed description of afterpulses generation see {\hyperref[\detokenize{theory:aptheory}]{\sphinxcrossref{\DUrole{std,std-ref}{Afterpulsing}}}}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{trise~:~double}}}
The time constant of the rising edge of the signal shape in nanoseconds. For a detailed description of signal generation see {\hyperref[\detokenize{theory:sigshapingtheory}]{\sphinxcrossref{\DUrole{std,std-ref}{Signal Shaping}}}}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{tfall~:~double}}}
The time constant of the rising edge of the signal shape in nanoseconds.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{cellrecovery~:~double}}}
The recovery time of the single SiPM cell in nanoseconds. This value is used to calculate the signal height in case a cell is hitted multiple times. A detailed description of this process can be found at {\hyperref[\detokenize{theory:cellrecoverytheory}]{\sphinxcrossref{\DUrole{std,std-ref}{Cell Recovery}}}}.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{tauapfast~:~double}}}
The time constant in nanoseconds of the distribution of the fast component of afterpulses delays from their main signal.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{tauapslow~:~double}}}
The time constant in nanoseconds of the distribution of the slow component of afterpulses delays from their main signal.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{ccgv~:~double}}}
The spread of the peak height of the single cell signal. Its value is the \(\sigma\) of the gaussian distribution of the peak height.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{SNR~:~double}}}
The signal to noise ratio of the noise generated. As signal it is considered the mean value of the first peak in the multi\sphinxhyphen{}photon peak spectrum and as noise it is considered the \(\sigma\) "zero peak".
To generate the white gaussian noise this value is converted in sigma:
\begin{equation*}
\begin{split}\sigma_{noise} = \sqrt{10^{-SNR/20}}\end{split}
\end{equation*}
\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{basespread~:~double}}}
The spread of the baseline value of the signal in units of \(\sigma\). This is currently set to 0 because the baseline subtraction is turned off too.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{siglen~:~int}}}
The length in nanoseconds of the signal to generate.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{sampling~:~double}}}
The sampling time intended as time granularity of the signal to generate. This means that two consecutive point in the signal are separated by a \(\Delta t=\) sampling.

\begin{sphinxadmonition}{important}{Important:}
Keep in mind that the total number of samples per signal is given by \(siglen/sampling\) so generating signals with many points after the region of interest or with too small sampling time may slow down a lot the computation of the signals.
\end{sphinxadmonition}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{intstart~:~double}}}
Starting time of the integration gate in nanoseconds. Must be greater than 0 and smaller than the signal length. For more details on signal analysis see {\hyperref[\detokenize{theory:signalanalysistheory}]{\sphinxcrossref{\DUrole{std,std-ref}{Signal Analysis}}}}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{intgate~:~double}}}
Lenght of the integration gate in nanoseconds. Must be greater than 0 and smaller than \(siglen - intstart\).

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{pregate~:~double}}}
Lenght of the pregate in nanoseconds. The pregate is placed before the intstart. This feature is currently being unused since the baseline subtraction is turned off.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{fastDCR~:~bool}}}
If true enables faster generation of dark count events.

\begin{sphinxadmonition}{warning}{Warning:}
This feature is still experimental. The results given by activating this option are acceptable but still to discuss.
Use this feature just for debugging purposes and not for actual data production.
\end{sphinxadmonition}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{fastXT~:~bool}}}
If true enables faster generation of optical crosstalk events.

\begin{sphinxadmonition}{warning}{Warning:}
This feature is still experimental. The results given by activating this option are acceptable but still to discuss.
Use this feature just for debugging purposes and not for actual data production.
\end{sphinxadmonition}

\end{fulllineitems}



\chapter{Theory}
\label{\detokenize{theory:theory}}\label{\detokenize{theory::doc}}
In this section the physical background of the phenomena related to SiPM signal generation are explained along with the algorithm used to describe them.


\section{SiPM}
\label{\detokenize{theory:sipm}}
SiPMs are state of the art light detectors with single photon sensitivity and photon counting capabilities.

A SiPM is composed by a dense matrix of Single Photon Avalanche Photo Diodes (SPADs) operated in Geiger\sphinxhyphen{}Muller mode. The impact of a photon on the single APD of the SiPM produces an electron \sphinxhyphen{} hole pair that, due to the intense electric field, triggers an avalanche of charge carriers that can be collected and measured.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=250\sphinxpxdimen]{{simpmarray}.jpg}\hspace*{\fill}}

Each single cell of the SiPM provides a binary information (hitted or not hitted). Since all APDs are almost identical they produce the same signal amplitude when a photon is detected, so by summing up the signals of each cell it is possible to reconstruct the total number of cells that have produced an avalanche.
Thus the signal amplitude of the SiPM is expected to be proportional to the number of triggered cells and so to the number of impinging photons.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=250\sphinxpxdimen]{{signals}.png}\hspace*{\fill}}


\section{Cell Recovery}
\label{\detokenize{theory:cell-recovery}}\label{\detokenize{theory:cellrecoverytheory}}

\section{Dark Counts}
\label{\detokenize{theory:dark-counts}}\label{\detokenize{theory:dcrtheory}}

\section{Optical Crosstalk}
\label{\detokenize{theory:optical-crosstalk}}\label{\detokenize{theory:xttheory}}

\section{Afterpulsing}
\label{\detokenize{theory:afterpulsing}}\label{\detokenize{theory:aptheory}}

\section{Signal Shaping}
\label{\detokenize{theory:signal-shaping}}\label{\detokenize{theory:sigshapingtheory}}

\section{Signal Analysis}
\label{\detokenize{theory:signal-analysis}}\label{\detokenize{theory:signalanalysistheory}}

\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}